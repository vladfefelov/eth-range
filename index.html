<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Грид-бот ETH/USDT (расширенный анализ)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    #chart-container {
      width: 90%;
      max-width: 900px;
      height: 450px;
      margin: 20px auto;
    }
    canvas {
      background: #f8f8f8;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      margin: 10px;
    }
    #result {
      font-size: 16px;
      margin-bottom: 10px;
      text-align: left;
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
      white-space: pre-wrap; /* Для переноса строк и сохранения форматирования */
    }
    .mode-active {
      background-color: #4CAF50;
      color: white;
    }
  </style>
</head>
<body>
  <h1>Грид-бот ETH/USDT (расширенный анализ)</h1>

  <div>
    <button onclick="calculateRange()">Рассчитать диапазон</button>
  </div>

  <p id="result"></p>
  <div id="chart-container">
    <canvas id="priceChart"></canvas>
  </div>

  <script>
    // Основные настройки анализа
    const ANALYSIS_SETTINGS = {
      historicalDays: 7,    // Увеличим период для более общей картины
      volumeThreshold: 0.6, // Порог значимости уровня по объему (можно подбирать 0.5-0.8)
      keyLevelProximityFactor: 0.05, // Насколько близко к текущей цене искать ключевые уровни (5% от цены)
      atrPeriod: 14,         // Период ATR
      atrMultiplierSupport: 1.5, // Множитель ATR для определения запасной поддержки
      atrMultiplierResistance: 1.5, // Множитель ATR для определения запасного сопротивления
      priceSmoothingPeriod: 5 // Период EMA для сглаживания цены (используется как центр)
    };

    // Расчет EMA (Exponential Moving Average)
    function calcEMA(data, period) {
      if (data.length < period) return []; // Недостаточно данных
      const k = 2 / (period + 1);
      let emaArray = [];
      // Начальное значение SMA
      let sum = data.slice(0, period).reduce((a, b) => a + b, 0);
      emaArray.push(sum / period);
      // Расчет EMA для остальной части
      for (let i = period; i < data.length; i++) {
        let ema = data[i] * k + emaArray[emaArray.length - 1] * (1 - k);
        emaArray.push(ema);
      }
      // Добавляем NaN в начало, чтобы длина совпадала с исходными данными
      return Array(period - 1).fill(NaN).concat(emaArray);
    }

    // Поиск значимых уровней (улучшенный)
    function findKeyLevels(prices, highs, lows, volumes, percentThreshold) {
      const levels = [];
      const minPrice = Math.min(...lows); // Используем мин/макс по low/high
      const maxPrice = Math.max(...highs);
      // Динамический шаг цены, например, 1/1000 диапазона или 0.1% от средней цены
      const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
      const priceStep = Math.max((maxPrice - minPrice) / 200, avgPrice * 0.001); // Берем 200 шагов или 0.1%

      for (let level = minPrice; level <= maxPrice; level += priceStep) {
        const rangeMin = level - priceStep / 2;
        const rangeMax = level + priceStep / 2;

        let volumeSum = 0;
        let touchCount = 0; // Считаем свечи, коснувшиеся уровня

        for (let i = 0; i < prices.length; i++) {
          // Проверяем, пересекает ли диапазон свечи (low-high) текущий уровень
          if (lows[i] <= rangeMax && highs[i] >= rangeMin) {
            volumeSum += volumes[i];
            touchCount++;
          }
        }

        if (touchCount > 0 && volumeSum > 0) {
           // Можно взвешивать силу не только по объему, но и по кол-ву касаний
           // strength: volumeSum * Math.log1p(touchCount) - простая идея
          levels.push({
            price: level,
            strength: volumeSum, // Пока оставим просто объем
            touches: touchCount
          });
        }
      }

      if (levels.length === 0) return [];

      // Нормализуем силу уровней (0-1)
      const maxStrength = Math.max(...levels.map(l => l.strength));
      if (maxStrength > 0) {
          levels.forEach(level => {
            level.strength = level.strength / maxStrength;
          });
      }

      // Фильтруем по порогу и сортируем по силе убывания
      return levels
        .filter(level => level.strength >= percentThreshold)
        .sort((a, b) => b.strength - a.strength); // Сортируем по силе
    }

    // Расчет ATR (Average True Range)
    function calcATR(highs, lows, closes, period) {
      let trValues = [];
      if (highs.length <= period) return NaN; // Недостаточно данных

      // Первый TR - просто high - low
       trValues.push(highs[0] - lows[0]);

      // Остальные TR
      for (let i = 1; i < highs.length; i++) {
        const tr1 = highs[i] - lows[i];
        const tr2 = Math.abs(highs[i] - closes[i - 1]);
        const tr3 = Math.abs(lows[i] - closes[i - 1]);
        trValues.push(Math.max(tr1, tr2, tr3));
      }

      // Используем EMA для сглаживания TR -> ATR
      const atrArray = calcEMA(trValues, period);
      return atrArray.length > 0 ? atrArray[atrArray.length - 1] : NaN; // Берем последнее значение ATR
    }


    // Основная функция расчета
    async function calculateRange() {
      const symbol = "ETHUSDT";
      const interval = "1h"; // Используем часовые свечи
      const limit = Math.floor(ANALYSIS_SETTINGS.historicalDays * 24); // Кол-во свечей

      document.getElementById("result").innerHTML = "Загрузка данных...";
      if (window.myChart) window.myChart.destroy(); // Очищаем старый график

      try {
        // Загружаем исторические данные
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`);
        if (!response.ok) {
           throw new Error(`Ошибка API Binance: ${response.status} ${response.statusText}`);
        }
        const data = await response.json();

        if (!Array.isArray(data) || data.length === 0) {
          throw new Error("Ошибка API: данные не загружены или пусты.");
        }
        // Проверяем, что данных достаточно для расчетов
        if (data.length < Math.max(ANALYSIS_SETTINGS.atrPeriod, ANALYSIS_SETTINGS.priceSmoothingPeriod) + 1) {
            throw new Error(`Недостаточно данных (${data.length}) для расчетов с периодами ${ANALYSIS_SETTINGS.atrPeriod}/${ANALYSIS_SETTINGS.priceSmoothingPeriod}. Попробуйте увеличить historicalDays.`);
        }

        // Парсим данные
        const timestamps = data.map(item => parseInt(item[0])); // Используем timestamp для Luxon
        const closes = data.map(item => parseFloat(item[4]));
        const highs = data.map(item => parseFloat(item[2]));
        const lows = data.map(item => parseFloat(item[3]));
        const volumes = data.map(item => parseFloat(item[5]));

        const currentPrice = closes[closes.length - 1];

        // Сглаживаем цену для определения "центра"
        const smoothedPrices = calcEMA(closes, ANALYSIS_SETTINGS.priceSmoothingPeriod);
        const centerPrice = smoothedPrices[smoothedPrices.length - 1]; // Последнее значение EMA

        // Рассчитываем ATR для определения волатильности
        const atr = calcATR(highs, lows, closes, ANALYSIS_SETTINGS.atrPeriod);
         if (isNaN(atr)) {
             throw new Error("Не удалось рассчитать ATR. Возможно, недостаточно данных.");
         }


        // --- Улучшенное определение границ ---

        // 1. Ищем все сильные уровни
        const keyLevels = findKeyLevels(closes, highs, lows, volumes, ANALYSIS_SETTINGS.volumeThreshold);

        // 2. Ищем ближайший СИЛЬНЫЙ уровень поддержки ниже центральной цены
        let strongSupport = null;
        const potentialSupports = keyLevels
            .filter(level => level.price < centerPrice && level.price >= centerPrice * (1 - ANALYSIS_SETTINGS.keyLevelProximityFactor)) // Ищем ниже и не слишком далеко
            .sort((a, b) => b.price - a.price); // Сортируем: ближайшие сверху

        if (potentialSupports.length > 0) {
            strongSupport = potentialSupports[0].price; // Берем самый сильный из ближайших (т.к. отсортировано по силе в findKeyLevels, но потом отфильтровано)
                                                         // Лучше пересортировать по силе здесь: potentialSupports.sort((a, b) => b.strength - a.strength)[0].price;
                                                         // Или выбрать самый ближний по цене: strongSupport = potentialSupports[0].price;
            // Выберем самый сильный из близких:
             strongSupport = potentialSupports.sort((a, b) => b.strength - a.strength)[0].price;
        } else {
            // Запасной вариант на основе ATR от центральной цены
            strongSupport = centerPrice - atr * ANALYSIS_SETTINGS.atrMultiplierSupport;
             console.log("Сильный уровень поддержки не найден рядом, используем ATR fallback.");
        }
        // Убедимся, что поддержка не выше центральной цены
        strongSupport = Math.min(strongSupport, centerPrice - atr * 0.1); // Хотя бы чуть ниже центра

        // 3. Ищем ближайший СИЛЬНЫЙ уровень сопротивления выше центральной цены
        let strongResistance = null;
        const potentialResistances = keyLevels
             .filter(level => level.price > centerPrice && level.price <= centerPrice * (1 + ANALYSIS_SETTINGS.keyLevelProximityFactor)) // Ищем выше и не слишком далеко
             .sort((a, b) => a.price - b.price); // Сортируем: ближайшие снизу

        if (potentialResistances.length > 0) {
           // Выберем самый сильный из близких:
             strongResistance = potentialResistances.sort((a, b) => b.strength - a.strength)[0].price;
        } else {
            // Запасной вариант на основе ATR от центральной цены
            strongResistance = centerPrice + atr * ANALYSIS_SETTINGS.atrMultiplierResistance;
            console.log("Сильный уровень сопротивления не найден рядом, используем ATR fallback.");
        }
         // Убедимся, что сопротивление не ниже центральной цены
        strongResistance = Math.max(strongResistance, centerPrice + atr * 0.1); // Хотя бы чуть выше центра


        // 4. Финальные границы
        // Просто используем найденные сильные уровни (или их ATR-заменители)
        let finalLower = strongSupport;
        let finalUpper = strongResistance;

        // Дополнительная проверка: чтобы диапазон не был слишком узким или инвертированным
        const minWidth = atr * 0.5; // Минимальная ширина диапазона (например, половина ATR)
        if (finalUpper - finalLower < minWidth) {
            console.warn(`Расчетный диапазон (${finalLower.toFixed(2)} - ${finalUpper.toFixed(2)}) слишком узкий. Расширяем.`);
            const midPoint = (finalLower + finalUpper) / 2;
            finalLower = midPoint - minWidth / 2;
            finalUpper = midPoint + minWidth / 2;
        }
        if (finalLower >= finalUpper) {
             console.error("Ошибка расчета: нижняя граница выше или равна верхней. Используем запасной вариант ATR.");
             finalLower = centerPrice - atr * ANALYSIS_SETTINGS.atrMultiplierSupport;
             finalUpper = centerPrice + atr * ANALYSIS_SETTINGS.atrMultiplierResistance;
             // Повторная проверка на инверсию (маловероятно, но все же)
             if (finalLower >= finalUpper) finalLower = finalUpper - atr*0.1;
        }


        // Вывод результатов
        let resultHTML = `
          <b>Последняя цена:</b> ${currentPrice.toFixed(2)} USDT
          <b>Сглаженная цена (центр):</b> ${centerPrice.toFixed(2)} USDT
          <b>ATR (${ANALYSIS_SETTINGS.atrPeriod}):</b> ${atr.toFixed(2)} USDT
          <b>Расчетная поддержка:</b> ${strongSupport.toFixed(2)} USDT
          <b>Расчетное сопротивление:</b> ${strongResistance.toFixed(2)} USDT
          ---
          <b>Рекомендуемый диапазон: ${finalLower.toFixed(2)} - ${finalUpper.toFixed(2)} USDT</b>
          <b>Ширина диапазона:</b> ${(finalUpper - finalLower).toFixed(2)} USDT (${((finalUpper - finalLower)/centerPrice*100).toFixed(1)}%)
        `;

        document.getElementById("result").innerHTML = resultHTML;
        drawChart(closes, timestamps, finalLower, finalUpper, centerPrice);
      } catch (error) {
        console.error("Ошибка при расчете диапазона:", error);
        document.getElementById("result").innerText = `Ошибка: ${error.message}`;
      }
    }

    // Построение графика
    function drawChart(prices, timestamps, lowerBound, upperBound, centerPrice) {
      const ctx = document.getElementById("priceChart").getContext("2d");
      if (window.myChart) window.myChart.destroy();

      const labels = timestamps.map(ts => luxon.DateTime.fromMillis(ts)); // Используем Luxon для дат

      window.myChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: labels,
          datasets: [
            {
              label: "Цена ETH (Close)",
              data: prices,
              borderColor: "rgba(54, 162, 235, 1)",
              borderWidth: 1.5,
              fill: false,
              pointRadius: 0,
              tension: 0.1
            },
            {
              label: "Нижняя граница",
              data: Array(prices.length).fill(lowerBound),
              borderColor: "rgba(75, 192, 192, 1)",
              borderWidth: 2,
              borderDash: [5, 5],
              pointRadius: 0,
              fill: false
            },
            {
              label: "Верхняя граница",
              data: Array(prices.length).fill(upperBound),
              borderColor: "rgba(255, 99, 132, 1)",
              borderWidth: 2,
              borderDash: [5, 5],
              pointRadius: 0,
              fill: false
            },
             {
              label: "Сглаж. цена (Центр)",
              data: Array(prices.length).fill(centerPrice),
              borderColor: "rgba(255, 159, 64, 0.8)", // Оранжевый
              borderWidth: 1,
              pointRadius: 0,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              type: "time",
              adapters: {
                 date: { // Неявно используется chartjs-adapter-luxon
                     locale: 'ru-RU', // Попробуем указать локаль
                 }
              },
              time: {
                unit: "day",
                tooltipFormat: 'DD T', // Формат для всплывающих подсказок
                displayFormats: {
                    hour: 'HH:mm',
                    day: 'dd MMM', // Формат для оси X
                    month: 'MMM yyyy'
                }
              },
               ticks: {
                 source: 'auto', // Автоматическое определение шага
                 maxRotation: 0,
                 autoSkip: true,
               }
            },
            y: {
              ticks: { callback: (value) => value.toFixed(2) + " USDT" },
              // Добавим небольшой отступ сверху и снизу
              grace: '5%'
            }
          },
           plugins: {
                tooltip: {
                    mode: 'index',
                    intersect: false
                }
            },
            hover: {
                mode: 'nearest',
                intersect: true
            }
        }
      });
    }

     // Автоматический запуск расчета при загрузке страницы
     window.onload = calculateRange;

  </script>
</body>
</html>
